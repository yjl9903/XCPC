# UVa1585 Score

> 2018 - 1 - 14

# UVa1586 Molar Mass

> 2018 - 1 - 14

# UVa1225 Digit Counting

> 2018 - 1 - 14

# UVa455 Periodic Strings

> 2018 - 1 - 14

# UVa227 Puzzle

> 2018 - 1 - 14

cin.getline()等函数应用，输出格式控制

# UVa232 Crossword Answers

> 2018 - 1 - 15

# UVa1368 DNA Consensus String

> 2018 - 1 - 15

Runtime error 注意数组超界问题

# UVa232 The Dole Queue

> 2018 - 1 - 15

注意约瑟夫环，取余环形遍历数组的技巧。

# UVa202 Repeating Decimals

> 2018 - 1 - 16

超级痛苦的AC，第一道一开始看没思路的题，而且乍一看特别简单。
辗转相除法的应用。

# UVa10340 All in All

> 2018 - 1 - 16

# UVa1587 Box

> 2018 - 1 - 16

# UVa1588 Kickdown

> 2018 - 1 - 16

忘记减去‘0’。

# UVa11809 Floating-Point Numbers

> 2018 - 1 - 17

对大数取对数，查表。

# UVa1339 Ancient Cipher

> 2018 - 1 - 17

别打错变量名字。

# UVa489 Hangman Judge

> 2018 - 1 - 18

# UVa213 Message Decoding

> 2018 - 1 - 19

本题注意getchar()函数的使用。
 
# UVa512 Spreadsheet Tracking

> 2018 - 1 - 20

对着书上敲得，好不容易调试OK。

重点是，每行的指令同时执行，不会再删除某一行后，影响后面的，所以用新的表格储存指令得到的结果，方程前面推的影响后面。

# UVa12412 A Typical Homework

> 2018 - 1 - 26

解锁新技能：uDebug。

本题注意输入输出重定向记得打注释。

除数记得检查为0，样例给的都会很坑！！！

浮点数误差，记得使用EPS，防止精度问题。

注意别被格式坑了！

# UVa1589 Xiangqi

> 2018 - 1 - 27

又是一个把我搞得快崩溃的题，一开始没有把问题考虑好，采用边输入边检查攻击范围，没有考虑到后面的棋子。

第二个问题，黑将可以吃子的问题，采用的解决方法是车和炮的攻击范围，从一开始会被棋子打断（该位置不在范围），到包括该位置，即假如黑将吃了这个棋子，那么就进入攻击范围。

第三，又忘记把红将也设置为红车进行判定，这才把所有情况考虑周到，但是又忘记删掉重定向，最后才AC。

# UVa201 Squares

> 2018 - 1 - 27

敲开心！一发AC！

暴力数正方形的时候差点忘记了有两个横边，两个竖边

# UVa220 Othello

> 2018 - 1 - 28

这种棋啊什么玩意的题目是真的烦，情况没考虑好就要WA，而且对于我这种弱鸡代码写的非常冗余。

本题输出有很多坑，uDebug调试AC后，竟然还是WA。

无奈拿着这个代码自己和自己下黑白棋，最后无意间发现在边界的时候会有迷之吃子。

虽然分析代码后，发现问题不大？还是最后加了宏is进行判断，终于AC。

写的太丑了Orz。




# UVa572 Oil Deposits

> 2018 - 3 - 11

DFS求联通块。

# UVa679 Dropping Balls

> 2018 - 3 - 12

参考紫书证明。

# UVa122 Trees on the level

> 2018 - 3 - 13

一开始写的指针实现的版本，貌似存在内存泄漏问题，输入之间有蜜汁相互作用，后改为数组实现，AC。

# UVa548 Tree

> 2018 - 3 - 15

看的紫书的代码，建树过程主要通过build函数，传递4个参数，中序遍历起点、终点，后序遍历起点、终点，递归地建出整个树，注意到，后序遍历的最后一个数据为当前子树的根节点，在中序遍历结果中找到该节点，可以得到该节点左边范围为左子树，右边为右子树。此时开left和right两个数组，直接对权值进行编号，数据记录了左右儿子的序号，也就是左右儿子的权值。由此进行递归，将当前节点的左右儿子用build函数赋值，分别递归左子树和右子树，同时函数本身最后会返回当前根节点的权值。递归终止条件为，中序遍历起点大于终点（不知道为什么紫书没写后序遍历的起点终点关系）。

# UVa839 Not so Mobile

> 2018 - 3 - 19

一开始，自己题意貌似理解错误，物理太差了。

瞅了一眼紫书的源码，才明白自己原来写的有问题，忽略了对支点的考虑，而且也不需要开数组存整棵树。

紫书源码，精妙之处在于对每个节点质量更新的处理，使用了引用，更深处的递归的质量变化将会更新当前节点的质量。

# UVa699 The Falling Leaves

> 2018 - 3 - 20

建树，忘记了。

# UVa1103 Ancient Messages 

> 2018 - 3 - 20

复杂的DFS求联通块并染色。

# UVa10305 Ordering Tasks

> 2018 - 3 - 26

使用邻接矩阵建图，开一个vis数组记录节点是否被访问。

从第一个节点开始遍历，只要此节点未被访问过，则对其进行dfs。

dfs过程中，先对正在访问的节点记录为-1，则当后面dfs深入时，遇到指向的节点vis值为-1，则出现了环图，返回false，并逐层将false返回，每个节点的所有后继访问结束时，将vis值置为1，即已经被访问，之后到达dfs最深层次即为拓扑排序的尾部节点，并且如此层层搭建到顶端。

# UVa10129 Play on Words

> 2018 - 3 - 27

首先题目给了一个有向图，对于一个有向图的欧拉回路，要求每个节点的入度等于出度或者存在两个点入度出度相差1。

然后将图恢复为无向图，使用dfs判断图的联通性。

# UVa253 Cube Painting

> 2018 - 5 - 21

建立一个位置坐标，用pair储存相对颜色，模拟骰子旋转过程即可。

# UVa10763 Foreign Exchange

> 2018 - 5 - 22

建立map关联一组交换方向和其交换的人数，遍历判断是否来回相等。

**本题注意map的使用，C++11标准的容器遍历，auto类型。**

# UVa10391 Compound Words

> 2018 - 5 - 25

 注意：string和set的使用。

 10391-1：没有按照字典序输出。

 # UVa1595 Symmetry

 > 2018 - 5 - 27

 水题，对称轴取最左边和最右边的对称轴，扫一遍，二分找对称点。

 # UVa1590 IP Networks

 > 2018 - 5 - 28

 本题注意题意的理解，位运算操作的运用，**-1 = 0xFFFFFFF**。

# UVa12100 Printer Queue

> 2018 - 5 - 29

队列的模拟。

# UVa673 Parentheses Balance

> 2018 - 5 - 29

括号匹配，注意判断匹配栈非空。

# UVa712 S-Trees

> 2018 - 5 - 29

满二叉树的二进制应用。

# UVa230 Borrowers

> 2018 - 5 - 29

注意getline函数对string的应用，多种数据结构结合，模拟过程。

# UVa536 Tree Recovery

> 2018 - 5 - 29

树的先序遍历和中序遍历重建树，输出后序遍历。

**注意递归建树过程，注意边界条件，即空子树情况。**

# UVa439 Knight Moves

> 2018 - 6 - 2

bfs模拟。

# UVa1600 Patrol Robot

> 2018 - 6 - 2

复杂的bfs问题，对于图上的障碍物最多可以连续走k次，直接地打vis数组的bfs会wa。

由于在一块联通的障碍物中移动多次，并非是最优的，需要对联通障碍物区域进行单独考虑，建立obs数组记录到达每个位置的最小走障碍次数，优化后AC。

P.S：都快忘记struct的构造了Orz。

# <font color=red>UVa12166 Equilibrium Mobile</font>

> 2018 - 6 - 3

本题感觉偏脑洞题，是一道数据结构好题，一开始想思路想了很久，但是TLE了。

TLE思路：显然，解必定大于等于0，小于n（叶子节点个数），至少可以固定一个去确定其他所有节点，那么我们遍历每一个叶子节点开始检查，回溯到根节点计算这一个过程一共修改了多少次，最后取修改次数的最小值。由于重量值上限接近于INT_MAX，那么在检查时很容易在判断祖先节点时爆出int范围，故wa，修改后答案正确，但是超时，分析复杂度O(n^2)，因为要遍历每个节点，在以此为基准遍历其他所有节点。

查了一波题解获得正确思路。同以上思路，更进一步注意到，当确定一个基准时，其他所有节点的重量都与基准和高度有关，基准的兄弟应该相等，基准的父亲和其兄弟的重量等于基准的两倍，以此类推。那么，使用dfs建树，过程中记录下每个节点的高度，扫描原序列，遇到'['，那么遍历他的两个孩子节点，遇到数组则将这个数字w * 2 ^ height，即 w << height，得到这个节点放在根节点处的重量，map记录根节点出现这个重量的次数。最后，在O(n)的时间内完成扫描后，遍历这个map，取得一个最大键值，代表了以某个重量为基准在叶子节点中出现次数最多，即修改次数最小。

# UVa804 Petri Net Simulation

> 2018 - 6 - 4

本题模拟过程即可，主要由于题目所给样例的答案唯一，因此一开始我考虑dfs跑所有情况，但实际上每步的选择对答案无影响，这个地方不知道怎么证明。

本题还有一个敲代码的问题在于，不能直接将很多map组在一起直接通过数组下标访问，会有迷之段错误，不是很懂。

# UVa806 Spatial Structures

> 2018 - 6 -5

四叉树模拟。

# UVa12118 Inspector's Dilemma

> 2018- 6 - 5

题解给出的是计算将所给的边连成欧拉回路最少添加次数。

我的思路是，对所有点按照联通进行分块，每块内奇点大于等于4时，增加res值，代表将所有奇点连在一起，构成一个欧拉通路，减1表示构成的不是回路。最后将每个块连在一个，这个过程中注意判断不够减的情况，防止负值。以上细节由udebug可知。

# UVa524 Prime Ring Problem

> 2018 - 6 - 7

回溯法。

# UVa129 Krypton Factor

> 2018 - 6 - 7

dfs，每次判断时，可以注意到前面一定是非重复串，所以判断的时候可以从最后一个判断。

# UVa140 Bandwidth

> 2018 - 6 - 8

有点难受，输入调试了很久T^T。

dfs+回溯+剪枝。

因为如果某一个序列的最大带宽已经大于当前答案，则后面的带宽一定大于当前答案，可以剪掉很多不必要的枚举。

# <font color="red">UVa1354 Mobile Computing</font>

> 2018 - 6 - 9

非常重要！

首先，本题最难点是递归遍历构造一棵二叉树。

根据紫书上的思路，采取的方法为每次取出两个节点，合并在一起成为一个节点，每个节点需要保存重量，左右长度信息。

dfs时，传递参数d表示递归深度，这里的递归深度可以视作已经遍历过得顶点数，在遍历到最后，d一定会等于s，当只剩最后两棵子树时，处理题目所需的答案。递归过程中，首先遍历取出不重复的两个未访问顶点，首先判定宽度是否满足房间大小，如果满足进入，处理是否是最后两棵子树，然后建立新的节点，并注意将新的节点的vis标记打成未访问过，当dfs深入结束回溯到此处时，要把此处的子树清除，做法为vis标记和cnt计数自减，恢复建立新节点所用的两个节点的vis标记。

最后输出答案时，注意几个坑点，如果深度为1时，并不会进入dfs，所以res=-1，但是此时宽度为0，其次-1不要输出成浮点数。

本题知识点：二叉树，dfs，回溯。

引申知识点：树上dp，位运算，子集枚举。

# <font color="red">UVa1601 The Morning after Halloween</font>

> 2018 - 6 - 9

非常重要！

个人感觉，几乎是单向BFS难度天花板。

迷宫中的空白拿出来用将坐标一维化建图，将三个幽灵的位置做成一个节点和其在遍历时的距离，bfs即可。

注意判断不可能的情况。

注意输入。

注意如何处理只有几个不同模式的统一处理，1,2,3个幽灵时添加(0,0)为空节点，考虑到(0,0)肯定是墙。

引申知识点：双向BFS，八数码问题，隐式图搜索， set和hash。

# <font color="red">UVa11212 Editing Book</font>

> 2018 - 6 - 24

非常重要！

IDA*模板题。

考虑当前dfs深度p，当前状态下h(n)表示每个数后继不正确的个数(1 3 2 4 5, 其中1, 3, 2后继不正确，4后继正确)。

显然每次剪切和粘贴的过程最大只会改变3个数的后继，因此h(n)最多减少3。

因此有 3 * p + h > 3 * maxd时，剪枝（之后最有dfs都减少了恰好3个，深度至少为 p + h / 3）。

# UVa208 Filetruck

> 2018 - 6 - 24

注意先用并查集判一下联通性。

# UVa12107 Digit Puzzle

> 2018 - 6 - 24

iterative deepening迭代加深搜索。

注意dfs枚举字典序的过程，从头扫到尾，从小扫到大！

成功冲上vj的榜单www

# UVa818 Cutting Chains

> 2018 - 6 - 25

迭代加深搜索。

注意题意的理解，每个顶点一条小圆环，打开小圆环时，其与其他所有边都断开了。

题目要求为断开某些顶点后，任一顶点度数至多为2，图上没有环，断掉顶点个数必须大于等于除去断掉的顶点的图上联通块个数减一（使用断掉的顶点将所有联通块连成一条链）。

# <font color="red">UVa307 Sticks</font>

> 2018 - 6 - 25

DFS + 剪枝！

+ 只搜索总长度整除目标长度的情况

+ 如果一个长度不匹配，则他下一个长度也不用搜索

+ 当前匹配的长度tot为0，且匹配失败，则剩下的一定都无法匹配，剪枝

+ 当前匹配的长度tot正好与len[i]凑在了一起，而dfs后失败，那么这时剩下的长度一定无法匹配，剪枝

+ 每次组合长度都是从前往后，每次取出的长度一定在前一次之后，匹配成功之后返回第一段

# UVa11882 Biggest Number

> 2018 - 6 - 27

反向迭代加深搜索 + 剪枝。

题目要求路径组成的最大数字，那么肯定要从位数最多的开始搜索，并且搜索过程中注意由大到小（加了减值这里好像没用了？）。

剪枝只要当前深度的dfs处理数组比res小，直接返回否则继续计算。

# UVa11846 Finding Seats Again

> 2018 - 6 - 28

我的思路：图上的路径，反复dfs。

参考AC标程：dfs，搜索小的矩形（题目已经交代，看漏了），从第一个位置逐个染色，搜索其后面存在的小矩形。

# UVa120 Stacks of Flapjacks 

> 2018 - 7 - 11

贪心模拟。

# UVa1605 Building for UN 

> 2018 - 7 - 11

构造。

# UVa1152 4 Values whose Sum is 0

> 2018 - 7 - 11

预处理 -(c + d)，排序。

枚举 a + b， 二分找对应的 -(c + d)。

# UVa11134 Fabled Rooks 

> 2018 - 7 - 11

横纵坐标分开看。

对于区间覆盖的诸多问题，要考虑到对区间右端点进行排序。

排序之后，贪心，每次都染该区间最左边可以染色的位置，若无法染色，则无解。

# UVa11054 Wine trading in Gergovia

> 2018 - 7 - 13

类比ants，供给和需求总是等价的，每次都从左边将酒运到右边。

# UVa1605 Amphiphilic Carbon Molecules 

> 2018 - 7 - 17

极角排序好题！

# UVa11572 Unique Snowflakes 

> 2018 - 7 - 23

维护左右两个指针，扫一遍这个数组即可。

# UVa714 Copying Books

> 2018 - 7 - 23

优化问题，转化为判断问题。

优化最大值的最小值，变成二分答案 + 判断。

总复杂度 O(n * log sum)

# UVa10954 Add All

> 2018 - 7 - 24

优先队列。

# UVa1025 A Spy in the Metro

> 2018 - 7 - 27

注意预处理不要想多了。

简单的dp。

# UVa10532 Combination! Once Again

> 2018 - 8 27

多重背包求方案数。