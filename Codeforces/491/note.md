# A. If at first you don't succeed...

简单容斥原理，A，B两个集合的人数，C为A，B的交集人数，注意|C|>|A|,|C|>|B|

# B. Getting an A

排序，贪心。

# C. Candies

二分，注意l,r的关系细节和浮点数误差。

# D. Bishwock

贪心，优先匹配两个拼起来的，然后匹配只有一个的，无法匹配则往后推。

# E. Bus Number

组合计数问题。

给定一个 0 ~ 9 的整数集合，求从这之中选择满足如下要求的种类数：

+ 集合中的数都至少出现一次。

+ 只能出现集合中有的数（包括个数），不能出现未出现的数，以及出现超过集合出现次数个数的数。

+ 第一个数不能为0。

由于第一位数有特殊要求，那么我们先取定第一个数为 1 ~ 9 中集合出现过的数，回溯思想，该数出现次数-1后，dfs，返回后恢复+1。

dfs用于计算给定第一位后的每种每个数出现次数情况的排列总数。

维护一个vector：v,用于表示当前情况，即每个数的出现次数。

因为不同情况之间只要每个数出现次数不同，肯定不会重复计数。

dfs到最深处已经填满9个数时，计算一共有多少数s，则情况数为 s!，因为每个数可能出现多次，因此需要那结果去除 (该数出现次数)!，即可得到对应这种情况总排列数。

